package fernuni.propra.algorithm.util;

import java.util.Collection;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;

import fernuni.propra.internal_data_model.Point;

/**
 * A rectangle that can also be tagged, i.e. have a set of integers that represent the tags.
 * <p>
 * The {@link RectangleWithTag} is designed to represent an original partial rectangle of an {@link IRoom}
 * instance.
 * The tags typically represent the portions of the {@link IRoom} that are illuminated if the associated
 * {@link RectangleWithTag} is illuminated. This means that the union of the
 *  tags of all {@RectangleWithTag}s of an {@link IRoom} should be equal to all tags, i.e. all portions of the
 *  {@link IRoom}. The tags are stored internally as a {@link HashSet}<{@link Integer}>.
 * <p> 
 * <p>
 * Extended classes: {@link Rectangle}
 * <p>
 * @author alex
 *
 */
public class RectangleWithTag extends Rectangle{

	private HashSet<Integer> tags = new HashSet<Integer>(); // the tags of the Rectangle
	
	/**
	 * Constructor
	 * @param p1 : left bottom {@link Point}
	 * @param p3 : top right {@link Point}
	 * @param initialTags : a {@link List} of initial tags.
	 */
	public RectangleWithTag(Point p1, Point p3, Collection<Integer> initialTags) {
		super(p1,p3);
		if (initialTags != null) {
			tags.addAll(initialTags);
		}
	}
	
	/**
	 * 
	 * @param rectangle
	 * @param initialTags
	 */
	public RectangleWithTag(Rectangle rectangle, Collection<Integer> initialTags) {
		this(rectangle.getP1(), rectangle.getP3(), initialTags);
	}
	
	public RectangleWithTag(Point p1, Point p3, Integer initialTag) {
		super(p1,p3);
		if (initialTag != null) {
			tags.add(initialTag);
		}
	}
	
	public RectangleWithTag(Rectangle rectangle, Integer initialTag) {
		this(rectangle.getP1(),rectangle.getP3(), initialTag);
	}
	
	public boolean containsTag(Integer tag) {
		return tags.contains(tag);
	}

	public void addTag(Integer tag) {
		tags.add(tag);
	}
	
	public void addTags(Iterator<Integer> tagIterator) {
		while(tagIterator.hasNext()) {
			this.tags.add(tagIterator.next());
		}
	}
	
	public Iterator<Integer> getTagIterator() {
		return tags.iterator();
	}
	
	public boolean tagsOfOtherRectangleAreSubsetOfThisTags(RectangleWithTag other) { //TODO implement with contains all
		boolean subset = true;
		Iterator<Integer> tagsOfOther = other.getTagIterator();
		while(tagsOfOther.hasNext()) {
			if (!tags.contains(tagsOfOther.next())) {
				subset = false;
				break;
			}
		}
		return subset;
	} 
	
	
	public boolean tagsAreEqual(RectangleWithTag other) {
		return this.tags.containsAll(other.tags) && other.tags.containsAll(this.tags);
	}
	
	public Rectangle getRectangle() {
		return new Rectangle(getP1(), getP3());
	}
	
	public HashSet<Integer> getCopyOfTags() { 
		HashSet<Integer> outTags = new HashSet<Integer>();
		for (Integer tag : tags) {
			outTags.add(tag);
		}
		return outTags;
	}
	
	
	private int getSumOfTags() {
		int result = 0;
		for (Integer tag: tags) {
			result = result + tag;
		}
		return result;
	}
	
	@Override
	public boolean equals(Object o) {
		if (o == this) return true;
		if(!(o instanceof RectangleWithTag)) {
			return false;
		}
		RectangleWithTag r = (RectangleWithTag) o;
		return getP1().isEqual(r.getP1()) && getP2().isEqual(r.getP2()) 
				&& getP3().isEqual(r.getP3()) && getP4().isEqual(r.getP4()) && getSumOfTags() == r.getSumOfTags() ;
	}
	
	@Override
	public int hashCode() {
		int result = 17;
		result = 31 * result + getP1().hashCode();
		result = 31 * result + getP3().hashCode();
		result = 31 * result + getSumOfTags();
		return result;
	}
	
}
