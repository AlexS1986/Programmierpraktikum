package fernuni.propra.algorithm;

import java.util.List;

import fernuni.propra.internal_data_model.IRoom;
import fernuni.propra.internal_data_model.Lamp;


public class SolveK extends Thread{
	private IRuntimeInformation runTimeInformation;
	private volatile IRoom room;
	private ICandidateSearcher candidateSearcher;
	private IPositionOptimizer positionOptimizer;
	private boolean computationFinished;
	List<Lamp> bestSolution;
	
	public SolveK(IRoom room, IRuntimeInformation runTimeInformation) {
		this.room = room;
		this.runTimeInformation = runTimeInformation;
		this.candidateSearcher = AlgorithmFactory.getAlgorithmFactory().createCandidateSearcher();
		this.positionOptimizer = AlgorithmFactory.getAlgorithmFactory().createPositionOptimizer();
	}
	
	
	
	
	public void solve(IRuntimeInformation runTimeInformation, IRoom room) throws CandidateSearcherException{
		List<Lamp> candidates = candidateSearcher.searchCandidates(room, 
				runTimeInformation);
		
		positionOptimizer.optimizePositions(room, 
				candidates, runTimeInformation); 
		}

	@Override
	public void run() {
		
		boolean isSolved = false;
		do {
			try {
				solve(runTimeInformation, room);
			} catch (CandidateSearcherException e) {
				//TODO
			}
			if (isInterrupted()) System.out.println("hi");
		} while(!isInterrupted() && !isSolved);
		
		
		bestSolution = positionOptimizer.getCurrentBestSolution(); // might be null
		
		if(bestSolution != null) {
			room.replaceLamps(bestSolution);
		}
		
		setComputationFinished(true);
		
	}
	
	//public synchronized boolean getComputationFinished() {
		
	//	return computationFinished;
	//}
	
	private synchronized void setComputationFinished(boolean computationFinished) {
		this.computationFinished = computationFinished;
		notifyAll();
	}
	
	public synchronized void testIfComputationFinished() throws InterruptedException{
		while(!computationFinished) {
			wait();
		}
	}
	
	
}
