package fernuni.propra.algorithm;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;

import fernuni.propra.algorithm.util.Rectangle;
import fernuni.propra.algorithm.util.RectangleWithTag;
import fernuni.propra.internal_data_model.IRoom;
import fernuni.propra.internal_data_model.Point;

public class CandidateSearcher  implements ICandidateSearcher{

	private IOriginalPartialRectanglesFinder originalRectanglesFinder;
	private IRoom room;
	
	public CandidateSearcher(IRoom room, IOriginalPartialRectanglesFinder originalPartialRectanglesFinder) {
		this.room = room;
		this.originalRectanglesFinder = originalPartialRectanglesFinder;
	}

	@Override
	public List<Point> searchCandidates(IRuntimeCandidateSearcher runtimeCandidateSearcher) throws CandidateSearcherException {
		
		List<Point> centersOfReducedRectangles = null;
		try {
			//sortWallsToContainers(room);
			
			//constructOriginalPartialRectangles();
			
			ArrayList<RectangleWithTag> originalRectangles = originalRectanglesFinder.findOriginalPartialRectangles(room, runtimeCandidateSearcher);
			List<RectangleWithTag> reducedRectangles = reduceRectangles(originalRectangles);
			
			centersOfReducedRectangles = new LinkedList<Point>();
			for (RectangleWithTag rectangle : reducedRectangles) {
				centersOfReducedRectangles.add(rectangle.getCenter());
			}
			
			
		} catch (OriginalPartialRectanglesFinderException  e) {
			throw new CandidateSearcherException(e);
		}
		
		return centersOfReducedRectangles;	
		
	}

	
	ArrayList<RectangleWithTag> constructOriginalPartialRectangles() {
		
	}


	/* void reduceRectangles() {
		
		HashSet<RectangleWithTag> reducedRectangles = new HashSet<RectangleWithTag>();
		ArrayList<RectangleWithTag> lastIterationReducedRectangles = originalRectangles;
		
		
		HashSet<Integer> originalTagsAlreadyConsideredInOverLap = new HashSet<Integer>();
		
		boolean combinationsOccured = false; // to determine to stop further iterations
		for (int i = 0; i< lastIterationReducedRectangles.size(); i++) {
			RectangleWithTag rectangleWithTagI = lastIterationReducedRectangles.get(i);
			boolean validOverlapFoundForI = false; // if no valid overlap found -> keep partial area
			for (int j = i+1; j< lastIterationReducedRectangles.size(); j++) {
				RectangleWithTag rectangleWithTagJ = lastIterationReducedRectangles.get(j);
				Rectangle overlappingRectangle = rectangleWithTagI.overlap(rectangleWithTagJ);	
				
				if (overlappingRectangle != null) { // overlap found
					HashSet<Integer> tagsOfOverlap= new HashSet<Integer>();
				
					Iterator<Integer> tagsI = rectangleWithTagI.getTagIterator();
					Iterator<Integer> tagsJ = rectangleWithTagJ.getTagIterator();
					
					while(tagsI.hasNext()) {
						tagsOfOverlap.add(tagsI.next());
					}
					
					while(tagsJ.hasNext()) {
						tagsOfOverlap.add(tagsJ.next());
					}
					
					RectangleWithTag newRectangleWithTag = new RectangleWithTag(overlappingRectangle, null);
					newRectangleWithTag.addTags(tagsOfOverlap.iterator());
					

					
					if (newRectangleWithTag.getCopyOfTags().containsAll(rectangleWithTagI.getCopyOfTags())) { // tags of rI are subset of overlap
						reducedRectangles.add(newRectangleWithTag);
						originalTagsAlreadyConsideredInOverLap.addAll(tagsOfOverlap);
						combinationsOccured = true;
						validOverlapFoundForI = true;
					}
							
				}
			}
			
			if (!validOverlapFoundForI && !originalTagsAlreadyConsideredInOverLap.containsAll(rectangleWithTagI.getCopyOfTags())) {
				reducedRectangles.add(rectangleWithTagI);
			}
			
		
		}
		
	} */
	
	
	static List<RectangleWithTag> reduceRectangles(ArrayList<RectangleWithTag> originalRectangles) {
		
		// die die im letzten schritt keinen overlap hatten m√ºssen auch nicht mehr angeschaut werden
		
		
		ArrayList<RectangleWithTag> lastIterationRectangles = originalRectangles;
		
		
		boolean combinationsOccured; // to determine to stop further iterations
		do {
			
			combinationsOccured = false;
			HashSet<RectangleWithTag> currentIterationRectangles = new HashSet<RectangleWithTag>();
			
			HashSet<Integer> originalTagsAlreadyCoveredInIteration = new HashSet<Integer>();
			
			
			for (int i = 0; i< lastIterationRectangles.size(); i++) {
				RectangleWithTag rectangleWithTagI = lastIterationRectangles.get(i);
				boolean validOverlapFoundForI = false; // if no valid overlap found -> keep partial area
				for (int j = i+1; j< lastIterationRectangles.size(); j++) {
					RectangleWithTag rectangleWithTagJ = lastIterationRectangles.get(j);
					Rectangle overlappingRectangle = rectangleWithTagI.overlap(rectangleWithTagJ);	
					
					if (overlappingRectangle != null) { // overlap found
						
						// determine tags of overlap
						HashSet<Integer> tagsOfOverlap= new HashSet<Integer>();
						Iterator<Integer> tagsI = rectangleWithTagI.getTagIterator();
						Iterator<Integer> tagsJ = rectangleWithTagJ.getTagIterator();	
						while(tagsI.hasNext()) {
							tagsOfOverlap.add(tagsI.next());
						}
						while(tagsJ.hasNext()) {
							tagsOfOverlap.add(tagsJ.next());
						}
						
						RectangleWithTag overlappingRectangleWithTag = new RectangleWithTag(overlappingRectangle, tagsOfOverlap);
						
						//add to next iteration rectangles if rectangle does not already exist
						if (!currentIterationRectangles.contains(overlappingRectangleWithTag)) { 
							currentIterationRectangles.add(overlappingRectangleWithTag);
							originalTagsAlreadyCoveredInIteration.addAll(overlappingRectangleWithTag.getCopyOfTags()); // all original rectangles are now covered
							combinationsOccured = true;
							validOverlapFoundForI = true;
						}
									
					}
				}
				
				if (!validOverlapFoundForI && !originalTagsAlreadyCoveredInIteration.containsAll(rectangleWithTagI.getCopyOfTags())) { // TODO test for contains necessary? 
					currentIterationRectangles.add(rectangleWithTagI);
					originalTagsAlreadyCoveredInIteration.addAll(rectangleWithTagI.getCopyOfTags());
				}
			}
			
			lastIterationRectangles = new ArrayList<RectangleWithTag>(currentIterationRectangles);
			
			
		} while(combinationsOccured);
		
		return lastIterationRectangles;
	}
		
		

}
