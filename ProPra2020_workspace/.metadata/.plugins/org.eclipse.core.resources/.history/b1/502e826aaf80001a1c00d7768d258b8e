package fernuni.propra.internal_data_model;

import java.util.List;

public class Point {
	private final double x;
	private final double y;
	private final static double TOL = 0.00001;
	public final static double INF = 100000000;
	
	public Point(double x, double y) {
		this.x = x;
		this.y = y;
	}
	
	public double getX() {
		return x;
	}
	
	public double getY() {
		return y;
	}
	
	public boolean isEqual(Point other) {
		if (other == null) return false;
		return (Math.abs(getX()-other.getX())  + Math.abs(getY()-other.getY()))  < TOL;
	}
	
	public boolean isOnLineSegment(Point p1, Point p2) {
		if (!p1.sameX(p2) && !p1.sameY(p2)) throw new IllegalArgumentException("Input is not a horizontal or vertical line!");
		boolean xAgrees = this.sameX(p1) 
				&& this.sameX(p2);
		boolean yAgrees = Point.agrees(getY(), p1.getY()) 
				&& Point.agrees(getY(), p2.getY());
		boolean xInRange = isInRange(getX(), p1.getX(), p2.getX());
		boolean yInRange = isInRange(getY(), p1.getY(), p2.getY());
		return (xAgrees && yInRange) || (yAgrees && xInRange);
	}
	
	public boolean isOnLineSegment (LineSegment lineSegment) {
		return isOnLineSegment(lineSegment.getP1(), lineSegment.getP2());
	}
	
	
	boolean sameX(Point other) {
		return Point.agrees(this.x, other.x);
	}
	
	boolean sameY(Point other) {
		return Point.agrees(this.y, other.y);
	}
	
	boolean largerX(Point other) {
		return Point.isLarger(this.x, other.x);
	}
	
	boolean largerY(Point other) {
		return Point.isLarger(this.y, other.y);
	}
	
	public boolean isInsidePolygon(List<LineSegment> lineSegments) {
		// pre lineSegment must be a valid polygonial
		LineSegment testLineSeg = new LineSegment(this, new Point(INF, getY()));
		
		int intersectionCount = 0;
		for (LineSegment lineSegment : lineSegments) {
			try {
				testLineSeg.intersectionWithLinesegment(lineSegment);
				if (isOnLineSegment(lineSegment.getP1(), lineSegment.getP2())) {
					return true; // if point is on wall -> point is in polygonial
				} else {
					intersectionCount++;
				}
			} catch (LineSegmentException e) {
			}
		}
		if ((intersectionCount % 2) == 0) { // if number of intersections is odd -> point is in polygonial
			return false;
		} else {
			return true;
		}	
	}
	
	public boolean isInXRange(double xLow, double xHigh) {
		if (xLow>xHigh) throw new IllegalArgumentException("xLow > xHigh");
		return isInRange(getX(), xLow, xHigh);
	}
	
	public boolean isInYRange(double yLow, double yHigh) {
		if(yLow > yHigh) throw new IllegalArgumentException("yLow > yHigh");
		return isInRange(getY(), yLow, yHigh);
	}
	
	private static boolean agrees(double x, double x1) {
		return Math.abs(x-x1)<TOL;
	}
	
	private static boolean isLarger(double x, double x1) {
		return x-x1 > TOL;
	}
	
	private static  boolean isInRange(double x, double x1, double x2) {
		return (Math.min(x1, x2) < x + TOL) && (Math.max(x1, x2) > x - TOL);				
	}
	


}
