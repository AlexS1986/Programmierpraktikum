package fernuni.propra.file_processing;

import fernuni.propra.internal_data_model.IRoom;
import fernuni.propra.internal_data_model.Lamp;
import fernuni.propra.internal_data_model.Point;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.LinkedList;
import java.util.List;

import org.jdom2.DocType;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.JDOMFactory;
import org.jdom2.input.SAXBuilder;
import org.jdom2.input.sax.XMLReaders;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;

public class FilePersistence extends PersistenceAbstract {
    private static final String DTD = System.getProperty("user.dir")+"/../File_Processing_Component/Model/DataModel.dtd";    
    
	@Override
	public IRoom readInput(String xmlFilePath) {	
		Document document = null;
		InputStreamReader isr = null;
		try {
			File xmlFile = new File(xmlFilePath);
			if (!xmlFile.exists()) {
				throw new FileNotFoundException("File not found. Enter a valid file path.");
			}
			if(!xmlFile.isFile()) {
				throw new IOException("Path does not point to a file. Enter a valid file path.");
			}
			
			// insert internal DTD for validation
			isr = new FileReader(xmlFile);
			StringBuilder sb = new StringBuilder();
			
			int c = -1;
			while((c = isr.read()) != -1) {
				sb.append((char) c);
				if (c == 62) {
					break;
				}
			}
			
			sb.append(System.getProperty("line.separator"));
			sb.append(readDTDFile());
			sb.append(System.getProperty("line.separator"));
			while((c = isr.read()) != -1) {
				sb.append((char) c);
			}
			

			SAXBuilder builder = new SAXBuilder(XMLReaders.DTDVALIDATING);
			document = builder.build(new StringReader(sb.toString()));
			Element raumNode = document.getRootElement();
			
			Element cornersNode = raumNode.getChild("ecken");	
			List<Element> cornerNodes = cornersNode.getChildren("Ecke");
			List<Point> corners = new LinkedList<Point>();
			Point bottomMostRightMostPoint = null; // https://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order/1180256#1180256
			
			for(Element cornerNode : cornerNodes) {
				Point tmpPoint = new Point(Double.parseDouble(cornerNode.getChildText("x")), Double.parseDouble(cornerNode.getChildText("y")));
				corners.add(tmpPoint);
				if (bottomMostRightMostPoint != null ) {
					if (tmpPoint.getY()<= bottomMostRightMostPoint.getY()) {
						if (tmpPoint.getX()>bottomMostRightMostPoint.getX()) {
							bottomMostRightMostPoint = tmpPoint;
						}
					}
				} else {
					bottomMostRightMostPoint = tmpPoint;
				}
			}
			
			Element lampsNode = raumNode.getChild("lampen");
			List<Element> lampNodes = lampsNode.getChildren("Lampe");
			List<Lamp> lamps = new LinkedList<Lamp>();
			for (Element lampNode: lampNodes) {
				Lamp tmpLamp = new Lamp(Double.parseDouble(lampNode.getChildText("x")), Double.parseDouble(lampNode.getChildText("y")));
				lamps.add(tmpLamp);
			}
			
			

			
			//System.out.println("TEST");
			//System.out.println(sb.toString());
			
			
			//document = builder.build(new StringReader(sb.toString()));
			//document = (Document) builder.build(xmlFile);
			//String folder = System.getProperty("user.dir")+"/../File_Processing_Component/Model/";
			//System.out.println(readDTDFile());
			//if (document.getDocType() == null) {
				//System.out.println("kein doctype vorhanden");
				
				//DocType dt = new DocType("Raum", folder+"DataModel.dtd");
				
				//document.setDocType(dt);
				
		        //XMLOutputter xmlOutputter = new XMLOutputter(Format.getPrettyFormat());
		        //output xml to console for debugging
		        //xmlOutputter.output(doc, System.out);
		        //File outfile = new File("~/Desktop/test");
		        //xmlOutputter.output(document, new FileOutputStream("/Users/alex/Desktop/test"));
			//}
			
			//Element rootNode = document.getRootElement();
			//System.out.println(rootNode.toString());
			
		} catch (JDOMException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NumberFormatException e) {
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void writeOutput(IRoom room, String xmlFile) {
		// TODO Auto-generated method stub

	}
	
	private String readDTDFile() throws IOException{
		File dtdFile = new File(FilePersistence.DTD);
		
		InputStreamReader isr = null;
		//BufferedReader br = null; 
		
		StringBuilder sb = new StringBuilder();
		sb.append("<!DOCTYPE Raum [");
		//sb.append(System.getProperty("line.separator"));
		
		//TODO ohne readline 
		
		try {
			isr = new InputStreamReader(new FileInputStream(dtdFile));
			boolean firstTagRead = false;
			int c = -1;
			while((c=isr.read())!=-1) {
				if(firstTagRead) {
					sb.append((char) c);
					if (c==62) {
						//sb.append(System.getProperty("line.separator"));
					}
				} 
				else {
					if(c==62) {
						firstTagRead = true;
					}
				}
				
			}
		} catch (IOException e) {
			throw new IOException(e);
		} finally {
			if (isr != null) {
				try {
					isr.close();
				} catch(IOException e) {
					throw new IOException(e);
				}
			}
		}
		sb.append(System.getProperty("line.separator"));
		sb.append("]>");
		//sb.append(FilePersistence.LS);
		return sb.toString();
	}

	private boolean isValidCorners(List<Point> corners) {
		return isCounterClockWise(corners) && doesNotIntersect(corners);
	}
	
	private boolean isCounterClockWise(List<Point> corners) {
		return false;
	}
	
	private boolean doesNotIntersect(List<Point> corners) {
		return false;
	}


}
