package fernuni.propra.file_processing;

import fernuni.propra.internal_data_model.IRoom;
import fernuni.propra.internal_data_model.Lamp;
import fernuni.propra.internal_data_model.Point;
import fernuni.propra.internal_data_model.Wall;
import fernuni.propra.internal_data_model.WallException;

import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileReader;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.StringReader;
import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;

import org.jdom2.DocType;
import org.jdom2.Document;
import org.jdom2.Element;
import org.jdom2.JDOMException;
import org.jdom2.JDOMFactory;
import org.jdom2.input.SAXBuilder;
import org.jdom2.input.sax.XMLReaders;
import org.jdom2.output.Format;
import org.jdom2.output.XMLOutputter;

public class FilePersistence extends PersistenceAbstract {
    private static final String DTD = System.getProperty("user.dir")+"/../File_Processing_Component/Model/DataModel.dtd";    
    
	@Override
	public IRoom readInput(String xmlFilePath) {	
		Document document = null;
		InputStreamReader isr = null;
		try {
			File xmlFile = new File(xmlFilePath);
			if (!xmlFile.exists()) {
				throw new FileNotFoundException("File not found. Enter a valid file path.");
			}
			if(!xmlFile.isFile()) {
				throw new IOException("Path does not point to a file. Enter a valid file path.");
			}
			
			// insert internal DTD for validation
			isr = new FileReader(xmlFile);
			StringBuilder sb = new StringBuilder();
			
			int c = -1;
			while((c = isr.read()) != -1) {
				sb.append((char) c);
				if (c == 62) {
					break;
				}
			}
			
			sb.append(System.getProperty("line.separator"));
			sb.append(readDTDFile());
			sb.append(System.getProperty("line.separator"));
			while((c = isr.read()) != -1) {
				sb.append((char) c);
			}
			
			SAXBuilder builder = new SAXBuilder(XMLReaders.DTDVALIDATING);
			document = builder.build(new StringReader(sb.toString()));
			Element raumNode = document.getRootElement();
			
			Element cornersNode = raumNode.getChild("ecken");	
			List<Element> cornerNodes = cornersNode.getChildren("Ecke");
			LinkedList<Point> corners = new LinkedList<Point>();
			List<Wall> walls = new ArrayList<Wall>();
			Point bottomMostRightMostPoint = null; 
			
			for(Element cornerNode : cornerNodes) {
				Point tmpPoint = new Point(Double.parseDouble(cornerNode.getChildText("x")), Double.parseDouble(cornerNode.getChildText("y")));
				// add wall
				if (!corners.isEmpty()) {
					Wall newWall = new Wall(corners.getLast(), tmpPoint);
					if (wallDoesNotIntersectWalls(newWall, walls)) {
						if (newWall.perpendicular(walls.get(walls.size()-1))) {
							walls.add(newWall);
						} else {
							throw new IOException("Sucessive walls are not perpendicular. Please provide a valid room layout!");
						}	
					} else {
						throw new IOException("Walls intersect. Please provide a valid room layout!");
					}
				}
				
				// add corner
				corners.add(tmpPoint);
				if (bottomMostRightMostPoint != null ) {
					if (tmpPoint.getY()<= bottomMostRightMostPoint.getY()) {
						if (tmpPoint.getX()>bottomMostRightMostPoint.getX()) {
							bottomMostRightMostPoint = tmpPoint;
						}
					}
				} else {
					bottomMostRightMostPoint = tmpPoint;
				}
			}
			
			// add lamps
			Element lampsNode = raumNode.getChild("lampen");
			List<Element> lampNodes = lampsNode.getChildren("Lampe");
			List<Lamp> lamps = new LinkedList<Lamp>();
			for (Element lampNode: lampNodes) {
				Lamp tmpLamp = new Lamp(Double.parseDouble(lampNode.getChildText("x")), Double.parseDouble(lampNode.getChildText("y")));
				lamps.add(tmpLamp);
			}
			
			

			
			//System.out.println("TEST");
			//System.out.println(sb.toString());
			
			
			//document = builder.build(new StringReader(sb.toString()));
			//document = (Document) builder.build(xmlFile);
			//String folder = System.getProperty("user.dir")+"/../File_Processing_Component/Model/";
			//System.out.println(readDTDFile());
			//if (document.getDocType() == null) {
				//System.out.println("kein doctype vorhanden");
				
				//DocType dt = new DocType("Raum", folder+"DataModel.dtd");
				
				//document.setDocType(dt);
				
		        //XMLOutputter xmlOutputter = new XMLOutputter(Format.getPrettyFormat());
		        //output xml to console for debugging
		        //xmlOutputter.output(doc, System.out);
		        //File outfile = new File("~/Desktop/test");
		        //xmlOutputter.output(document, new FileOutputStream("/Users/alex/Desktop/test"));
			//}
			
			//Element rootNode = document.getRootElement();
			//System.out.println(rootNode.toString());
			
		} catch (JDOMException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} catch (NumberFormatException e) {
			e.printStackTrace();
		} catch (IOException e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		}
		
		
		// TODO Auto-generated method stub
		return null;
	}

	@Override
	public void writeOutput(IRoom room, String xmlFile) {
		// TODO Auto-generated method stub

	}
	
	private String readDTDFile() throws IOException{
		File dtdFile = new File(FilePersistence.DTD);
		
		InputStreamReader isr = null;
		//BufferedReader br = null; 
		
		StringBuilder sb = new StringBuilder();
		sb.append("<!DOCTYPE Raum [");
		//sb.append(System.getProperty("line.separator"));
		
		//TODO ohne readline 
		
		try {
			isr = new InputStreamReader(new FileInputStream(dtdFile));
			boolean firstTagRead = false;
			int c = -1;
			while((c=isr.read())!=-1) {
				if(firstTagRead) {
					sb.append((char) c);
					if (c==62) {
						//sb.append(System.getProperty("line.separator"));
					}
				} 
				else {
					if(c==62) {
						firstTagRead = true;
					}
				}
				
			}
		} catch (IOException e) {
			throw new IOException(e);
		} finally {
			if (isr != null) {
				try {
					isr.close();
				} catch(IOException e) {
					throw new IOException(e);
				}
			}
		}
		sb.append(System.getProperty("line.separator"));
		sb.append("]>");
		//sb.append(FilePersistence.LS);
		return sb.toString();
	}

	private boolean isValidCorners(List<Point> corners, Point bottomMostRightMostPoint) {
		return corners.size()>3  && doesNotIntersect(corners);
	}
	
	private boolean isCounterClockWise(List<Point> corners, Point bottomMostRightMostPoint) {
		// https://stackoverflow.com/questions/1165647/how-to-determine-if-a-list-of-polygon-points-are-in-clockwise-order/1180256#1180256
		int indexOfBMRMP = corners.indexOf(bottomMostRightMostPoint);
		Point previous;
		Point next;
		if (indexOfBMRMP == 0) {
			previous = corners.get(corners.size()-1);
			next = corners.get(indexOfBMRMP+1);
		} else if(indexOfBMRMP == (corners.size()-1)) {
			previous = corners.get(indexOfBMRMP-1);
			next = corners.get(0);
		} else {
			previous = corners.get(indexOfBMRMP-1);
			next = corners.get(indexOfBMRMP+1);
		}
		
		double dx1 = bottomMostRightMostPoint.getX()-previous.getX();
		double dx2 = next.getX() - bottomMostRightMostPoint.getX();
		
		double dy1 = bottomMostRightMostPoint.getY()-previous.getY();
		double dy2 = next.getY() - bottomMostRightMostPoint.getY();
		
		double crossProduct = dx1*dy2 - dx2*dy1;
		return crossProduct > 0;
	}
	
	
	private boolean wallDoesNotIntersectWalls(Wall wall, List<Wall> walls) {
		if (walls.isEmpty()) return true;
		boolean doesNotIntersect = true;
		for (int j = 0; j < walls.size(); j++) {
			try {
				Point intersectionPoint = wall.intersectionWithWall(walls.get(j));
				if (!intersectionPoint.isEqual(wall.getP1()) 
						&& !intersectionPoint.isEqual(wall.getP2()) ) {
					doesNotIntersect = false;
					break;
				}
			} catch (WallException e) {
				
			}
		}
		return doesNotIntersect;
	}
	
	private boolean pointIsInsideRoom(Point point, List<Wall> walls) {
		Wall testWall = new Wall(point, new Point(10000, point.getY()));
		
		int intersectionCount = 0;
		for (Wall wall : walls) {
			try {
				testWall.intersectionWithWall(wall);
				if (point.isOnLine(wall.getP1(), wall.getP2())) {
					return true;
				} else {
					intersectionCount++;
				}
			} catch (WallException e) {
				
			}
		}
		if ((intersectionCount % 2) == 0) { // if number of intersections is odd -> point is in room
			return false;
		} else {
			return true;
		}
		
	}


}
